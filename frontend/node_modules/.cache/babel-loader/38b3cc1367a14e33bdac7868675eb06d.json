{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar util = tslib_1.__importStar(require(\"./util\"));\n\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\nvar PRECEDENCE = {};\n[[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nvar FastPath = function FastPath(value) {\n  assert_1.default.ok(this instanceof FastPath);\n  this.stack = [value];\n};\n\nvar FPp = FastPath.prototype; // Static convenience function for coercing a value to a FastPath.\n\nFastPath.from = function (obj) {\n  if (obj instanceof FastPath) {\n    // Return a defensive copy of any existing FastPath instances.\n    return obj.copy();\n  }\n\n  if (obj instanceof types.NodePath) {\n    // For backwards compatibility, unroll NodePath instances into\n    // lightweight FastPath [..., name, value] stacks.\n    var copy = Object.create(FastPath.prototype);\n    var stack = [obj.value];\n\n    for (var pp = void 0; pp = obj.parentPath; obj = pp) stack.push(obj.name, pp.value);\n\n    copy.stack = stack.reverse();\n    return copy;\n  } // Otherwise use obj as the value of the new FastPath instance.\n\n\n  return new FastPath(obj);\n};\n\nFPp.copy = function copy() {\n  var copy = Object.create(FastPath.prototype);\n  copy.stack = this.stack.slice(0);\n  return copy;\n}; // The name of the current property is always the penultimate element of\n// this.stack, and always a String.\n\n\nFPp.getName = function getName() {\n  var s = this.stack;\n  var len = s.length;\n\n  if (len > 1) {\n    return s[len - 2];\n  } // Since the name is always a string, null is a safe sentinel value to\n  // return if we do not know the name of the (root) value.\n\n\n  return null;\n}; // The value of the current property is always the final element of\n// this.stack.\n\n\nFPp.getValue = function getValue() {\n  var s = this.stack;\n  return s[s.length - 1];\n};\n\nFPp.valueIsDuplicate = function () {\n  var s = this.stack;\n  var valueIndex = s.length - 1;\n  return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\n};\n\nfunction getNodeHelper(path, count) {\n  var s = path.stack;\n\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    var value = s[i];\n\n    if (n.Node.check(value) && --count < 0) {\n      return value;\n    }\n  }\n\n  return null;\n}\n\nFPp.getNode = function getNode(count) {\n  if (count === void 0) {\n    count = 0;\n  }\n\n  return getNodeHelper(this, ~~count);\n};\n\nFPp.getParentNode = function getParentNode(count) {\n  if (count === void 0) {\n    count = 0;\n  }\n\n  return getNodeHelper(this, ~~count + 1);\n}; // The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\n\n\nFPp.getRootValue = function getRootValue() {\n  var s = this.stack;\n\n  if (s.length % 2 === 0) {\n    return s[1];\n  }\n\n  return s[0];\n}; // Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\n\n\nFPp.call = function call(callback\n/*, name1, name2, ... */\n) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  var result = callback(this);\n  s.length = origLen;\n  return result;\n}; // Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\n\n\nFPp.each = function each(callback\n/*, name1, name2, ... */\n) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]); // If the callback needs to know the value of i, call\n      // path.getName(), assuming path is the parameter name.\n\n      callback(this);\n      s.length -= 2;\n    }\n  }\n\n  s.length = origLen;\n}; // Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\n\n\nFPp.map = function map(callback\n/*, name1, name2, ... */\n) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  var result = new Array(value.length);\n\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      result[i] = callback(this, i);\n      s.length -= 2;\n    }\n  }\n\n  s.length = origLen;\n  return result;\n}; // Returns true if the node at the tip of the path is wrapped with\n// parentheses, OR if the only reason the node needed parentheses was that\n// it couldn't be the first expression in the enclosing statement (see\n// FastPath#canBeFirstInStatement), and it has an opening `(` character.\n// For example, the FunctionExpression in `(function(){}())` appears to\n// need parentheses only because it's the first expression in the AST, but\n// since it happens to be preceded by a `(` (which is not apparent from\n// the AST but can be determined using FastPath#getPrevToken), there is no\n// ambiguity about how to parse it, so it counts as having parentheses,\n// even though it is not immediately followed by a `)`.\n\n\nFPp.hasParens = function () {\n  var node = this.getNode();\n  var prevToken = this.getPrevToken(node);\n\n  if (!prevToken) {\n    return false;\n  }\n\n  var nextToken = this.getNextToken(node);\n\n  if (!nextToken) {\n    return false;\n  }\n\n  if (prevToken.value === \"(\") {\n    if (nextToken.value === \")\") {\n      // If the node preceded by a `(` token and followed by a `)` token,\n      // then of course it has parentheses.\n      return true;\n    } // If this is one of the few Expression types that can't come first in\n    // the enclosing statement because of parsing ambiguities (namely,\n    // FunctionExpression, ObjectExpression, and ClassExpression) and\n    // this.firstInStatement() returns true, and the node would not need\n    // parentheses in an expression context because this.needsParens(true)\n    // returns false, then it just needs an opening parenthesis to resolve\n    // the parsing ambiguity that made it appear to need parentheses.\n\n\n    var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);\n\n    if (justNeedsOpeningParen) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nFPp.getPrevToken = function (node) {\n  node = node || this.getNode();\n  var loc = node && node.loc;\n  var tokens = loc && loc.tokens;\n\n  if (tokens && loc.start.token > 0) {\n    var token = tokens[loc.start.token - 1];\n\n    if (token) {\n      // Do not return tokens that fall outside the root subtree.\n      var rootLoc = this.getRootValue().loc;\n\n      if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {\n        return token;\n      }\n    }\n  }\n\n  return null;\n};\n\nFPp.getNextToken = function (node) {\n  node = node || this.getNode();\n  var loc = node && node.loc;\n  var tokens = loc && loc.tokens;\n\n  if (tokens && loc.end.token < tokens.length) {\n    var token = tokens[loc.end.token];\n\n    if (token) {\n      // Do not return tokens that fall outside the root subtree.\n      var rootLoc = this.getRootValue().loc;\n\n      if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {\n        return token;\n      }\n    }\n  }\n\n  return null;\n}; // Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\n\n\nFPp.needsParens = function (assumeExpressionContext) {\n  var node = this.getNode(); // This needs to come before `if (!parent) { return false }` because\n  // an object destructuring assignment requires parens for\n  // correctness even when it's the topmost expression.\n\n  if (node.type === \"AssignmentExpression\" && node.left.type === \"ObjectPattern\") {\n    return true;\n  }\n\n  var parent = this.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = this.getName(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in fact,\n  // only Expression nodes) need parentheses.\n\n  if (this.getValue() !== node) {\n    return false;\n  } // Only statements don't need parentheses.\n\n\n  if (n.Statement.check(node)) {\n    return false;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\" || node.extra && node.extra.parenthesized) {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            var po = parent.operator;\n            var pp = PRECEDENCE[po];\n            var no = node.operator;\n            var np = PRECEDENCE[no];\n\n            if (pp > np) {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert_1.default.strictEqual(parent.right, node);\n              return true;\n            }\n\n            break;\n          }\n\n        default:\n          return false;\n      }\n\n      break;\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence expressions in\n          // the head of for loops, traditional style dictates that e.g. i++,\n          // j++ should not be wrapped with parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"Literal\":\n      return parent.type === \"MemberExpression\" && isNumber.check(node.value) && name === \"object\" && parent.object === node;\n    // Babel 6 Literal split\n\n    case \"NumericLiteral\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          return true;\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      if (n.CallExpression.check(parent) && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      if (n.MemberExpression.check(parent) && name === \"object\" && parent.object === node) {\n        return true;\n      }\n\n      if (n.TSAsExpression && n.TSAsExpression.check(parent) && name === \"expression\" && parent.expression === node) {\n        return true;\n      }\n\n      return isBinary(parent);\n\n    case \"ObjectExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node) {\n        return true;\n      }\n\n      break;\n\n    case \"TSAsExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node && node.expression.type === \"ObjectExpression\") {\n        return true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n      if (name === \"declaration\" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node.callee)) {\n        return true;\n      }\n\n  }\n\n  if (parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n    return containsCallExpression(node);\n  }\n\n  if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {\n    return true;\n  }\n\n  return false;\n};\n\nfunction isBinary(node) {\n  return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n} // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n\n\nfunction isUnaryLike(node) {\n  return n.UnaryExpression.check(node) || // I considered making SpreadElement and SpreadProperty subtypes of\n  // UnaryExpression, but they're not really Expression nodes.\n  n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n}\n\nfunction containsCallExpression(node) {\n  if (n.CallExpression.check(node)) {\n    return true;\n  }\n\n  if (isArray.check(node)) {\n    return node.some(containsCallExpression);\n  }\n\n  if (n.Node.check(node)) {\n    return types.someField(node, function (_name, child) {\n      return containsCallExpression(child);\n    });\n  }\n\n  return false;\n}\n\nFPp.canBeFirstInStatement = function () {\n  var node = this.getNode();\n\n  if (n.FunctionExpression.check(node)) {\n    return false;\n  }\n\n  if (n.ObjectExpression.check(node)) {\n    return false;\n  }\n\n  if (n.ClassExpression.check(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nFPp.firstInStatement = function () {\n  var s = this.stack;\n  var parentName, parent;\n  var childName, child;\n\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    if (n.Node.check(s[i])) {\n      childName = parentName;\n      child = parent;\n      parentName = s[i - 1];\n      parent = s[i];\n    }\n\n    if (!parent || !child) {\n      continue;\n    }\n\n    if (n.BlockStatement.check(parent) && parentName === \"body\" && childName === 0) {\n      assert_1.default.strictEqual(parent.body[0], child);\n      return true;\n    }\n\n    if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\n      assert_1.default.strictEqual(parent.expression, child);\n      return true;\n    }\n\n    if (n.AssignmentExpression.check(parent) && childName === \"left\") {\n      assert_1.default.strictEqual(parent.left, child);\n      return true;\n    }\n\n    if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\n      assert_1.default.strictEqual(parent.body, child);\n      return true;\n    }\n\n    if (n.SequenceExpression.check(parent) && parentName === \"expressions\" && childName === 0) {\n      assert_1.default.strictEqual(parent.expressions[0], child);\n      continue;\n    }\n\n    if (n.CallExpression.check(parent) && childName === \"callee\") {\n      assert_1.default.strictEqual(parent.callee, child);\n      continue;\n    }\n\n    if (n.MemberExpression.check(parent) && childName === \"object\") {\n      assert_1.default.strictEqual(parent.object, child);\n      continue;\n    }\n\n    if (n.ConditionalExpression.check(parent) && childName === \"test\") {\n      assert_1.default.strictEqual(parent.test, child);\n      continue;\n    }\n\n    if (isBinary(parent) && childName === \"left\") {\n      assert_1.default.strictEqual(parent.left, child);\n      continue;\n    }\n\n    if (n.UnaryExpression.check(parent) && !parent.prefix && childName === \"argument\") {\n      assert_1.default.strictEqual(parent.argument, child);\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n};\n\nexports.default = FastPath;","map":{"version":3,"sources":["C:/Users/tara0/OneDrive/Bureau/Travail/Ing 4/Techno web/PROJECT_WEB_OCRES/frontend/node_modules/jscodeshift/node_modules/recast/lib/fast-path.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","assert_1","__importDefault","types","__importStar","util","n","namedTypes","isArray","builtInTypes","array","isNumber","number","PRECEDENCE","forEach","tier","i","op","FastPath","default","ok","stack","FPp","prototype","from","obj","copy","NodePath","create","pp","parentPath","push","name","reverse","slice","getName","s","len","length","getValue","valueIsDuplicate","valueIndex","lastIndexOf","getNodeHelper","path","count","Node","check","getNode","getParentNode","getRootValue","call","callback","origLen","argc","arguments","result","each","map","Array","hasParens","node","prevToken","getPrevToken","nextToken","getNextToken","justNeedsOpeningParen","canBeFirstInStatement","firstInStatement","needsParens","loc","tokens","start","token","rootLoc","comparePos","end","assumeExpressionContext","type","left","parent","Statement","extra","parenthesized","object","callee","po","operator","no","np","strictEqual","right","test","CallExpression","MemberExpression","TSAsExpression","expression","isBinary","body","ExportDefaultDeclaration","FunctionExpression","containsCallExpression","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","some","someField","_name","child","ObjectExpression","ClassExpression","parentName","childName","BlockStatement","ExpressionStatement","AssignmentExpression","ArrowFunctionExpression","SequenceExpression","expressions","ConditionalExpression","prefix","argument"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\r\nvar types = tslib_1.__importStar(require(\"ast-types\"));\r\nvar util = tslib_1.__importStar(require(\"./util\"));\r\nvar n = types.namedTypes;\r\nvar isArray = types.builtInTypes.array;\r\nvar isNumber = types.builtInTypes.number;\r\nvar PRECEDENCE = {};\r\n[\r\n    [\"||\"],\r\n    [\"&&\"],\r\n    [\"|\"],\r\n    [\"^\"],\r\n    [\"&\"],\r\n    [\"==\", \"===\", \"!=\", \"!==\"],\r\n    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\r\n    [\">>\", \"<<\", \">>>\"],\r\n    [\"+\", \"-\"],\r\n    [\"*\", \"/\", \"%\"],\r\n    [\"**\"],\r\n].forEach(function (tier, i) {\r\n    tier.forEach(function (op) {\r\n        PRECEDENCE[op] = i;\r\n    });\r\n});\r\nvar FastPath = function FastPath(value) {\r\n    assert_1.default.ok(this instanceof FastPath);\r\n    this.stack = [value];\r\n};\r\nvar FPp = FastPath.prototype;\r\n// Static convenience function for coercing a value to a FastPath.\r\nFastPath.from = function (obj) {\r\n    if (obj instanceof FastPath) {\r\n        // Return a defensive copy of any existing FastPath instances.\r\n        return obj.copy();\r\n    }\r\n    if (obj instanceof types.NodePath) {\r\n        // For backwards compatibility, unroll NodePath instances into\r\n        // lightweight FastPath [..., name, value] stacks.\r\n        var copy = Object.create(FastPath.prototype);\r\n        var stack = [obj.value];\r\n        for (var pp = void 0; (pp = obj.parentPath); obj = pp)\r\n            stack.push(obj.name, pp.value);\r\n        copy.stack = stack.reverse();\r\n        return copy;\r\n    }\r\n    // Otherwise use obj as the value of the new FastPath instance.\r\n    return new FastPath(obj);\r\n};\r\nFPp.copy = function copy() {\r\n    var copy = Object.create(FastPath.prototype);\r\n    copy.stack = this.stack.slice(0);\r\n    return copy;\r\n};\r\n// The name of the current property is always the penultimate element of\r\n// this.stack, and always a String.\r\nFPp.getName = function getName() {\r\n    var s = this.stack;\r\n    var len = s.length;\r\n    if (len > 1) {\r\n        return s[len - 2];\r\n    }\r\n    // Since the name is always a string, null is a safe sentinel value to\r\n    // return if we do not know the name of the (root) value.\r\n    return null;\r\n};\r\n// The value of the current property is always the final element of\r\n// this.stack.\r\nFPp.getValue = function getValue() {\r\n    var s = this.stack;\r\n    return s[s.length - 1];\r\n};\r\nFPp.valueIsDuplicate = function () {\r\n    var s = this.stack;\r\n    var valueIndex = s.length - 1;\r\n    return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\r\n};\r\nfunction getNodeHelper(path, count) {\r\n    var s = path.stack;\r\n    for (var i = s.length - 1; i >= 0; i -= 2) {\r\n        var value = s[i];\r\n        if (n.Node.check(value) && --count < 0) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nFPp.getNode = function getNode(count) {\r\n    if (count === void 0) { count = 0; }\r\n    return getNodeHelper(this, ~~count);\r\n};\r\nFPp.getParentNode = function getParentNode(count) {\r\n    if (count === void 0) { count = 0; }\r\n    return getNodeHelper(this, ~~count + 1);\r\n};\r\n// The length of the stack can be either even or odd, depending on whether\r\n// or not we have a name for the root value. The difference between the\r\n// index of the root value and the index of the final value is always\r\n// even, though, which allows us to return the root value in constant time\r\n// (i.e. without iterating backwards through the stack).\r\nFPp.getRootValue = function getRootValue() {\r\n    var s = this.stack;\r\n    if (s.length % 2 === 0) {\r\n        return s[1];\r\n    }\r\n    return s[0];\r\n};\r\n// Temporarily push properties named by string arguments given after the\r\n// callback function onto this.stack, then call the callback with a\r\n// reference to this (modified) FastPath object. Note that the stack will\r\n// be restored to its original state after the callback is finished, so it\r\n// is probably a mistake to retain a reference to the path.\r\nFPp.call = function call(callback /*, name1, name2, ... */) {\r\n    var s = this.stack;\r\n    var origLen = s.length;\r\n    var value = s[origLen - 1];\r\n    var argc = arguments.length;\r\n    for (var i = 1; i < argc; ++i) {\r\n        var name = arguments[i];\r\n        value = value[name];\r\n        s.push(name, value);\r\n    }\r\n    var result = callback(this);\r\n    s.length = origLen;\r\n    return result;\r\n};\r\n// Similar to FastPath.prototype.call, except that the value obtained by\r\n// accessing this.getValue()[name1][name2]... should be array-like. The\r\n// callback will be called with a reference to this path object for each\r\n// element of the array.\r\nFPp.each = function each(callback /*, name1, name2, ... */) {\r\n    var s = this.stack;\r\n    var origLen = s.length;\r\n    var value = s[origLen - 1];\r\n    var argc = arguments.length;\r\n    for (var i = 1; i < argc; ++i) {\r\n        var name = arguments[i];\r\n        value = value[name];\r\n        s.push(name, value);\r\n    }\r\n    for (var i = 0; i < value.length; ++i) {\r\n        if (i in value) {\r\n            s.push(i, value[i]);\r\n            // If the callback needs to know the value of i, call\r\n            // path.getName(), assuming path is the parameter name.\r\n            callback(this);\r\n            s.length -= 2;\r\n        }\r\n    }\r\n    s.length = origLen;\r\n};\r\n// Similar to FastPath.prototype.each, except that the results of the\r\n// callback function invocations are stored in an array and returned at\r\n// the end of the iteration.\r\nFPp.map = function map(callback /*, name1, name2, ... */) {\r\n    var s = this.stack;\r\n    var origLen = s.length;\r\n    var value = s[origLen - 1];\r\n    var argc = arguments.length;\r\n    for (var i = 1; i < argc; ++i) {\r\n        var name = arguments[i];\r\n        value = value[name];\r\n        s.push(name, value);\r\n    }\r\n    var result = new Array(value.length);\r\n    for (var i = 0; i < value.length; ++i) {\r\n        if (i in value) {\r\n            s.push(i, value[i]);\r\n            result[i] = callback(this, i);\r\n            s.length -= 2;\r\n        }\r\n    }\r\n    s.length = origLen;\r\n    return result;\r\n};\r\n// Returns true if the node at the tip of the path is wrapped with\r\n// parentheses, OR if the only reason the node needed parentheses was that\r\n// it couldn't be the first expression in the enclosing statement (see\r\n// FastPath#canBeFirstInStatement), and it has an opening `(` character.\r\n// For example, the FunctionExpression in `(function(){}())` appears to\r\n// need parentheses only because it's the first expression in the AST, but\r\n// since it happens to be preceded by a `(` (which is not apparent from\r\n// the AST but can be determined using FastPath#getPrevToken), there is no\r\n// ambiguity about how to parse it, so it counts as having parentheses,\r\n// even though it is not immediately followed by a `)`.\r\nFPp.hasParens = function () {\r\n    var node = this.getNode();\r\n    var prevToken = this.getPrevToken(node);\r\n    if (!prevToken) {\r\n        return false;\r\n    }\r\n    var nextToken = this.getNextToken(node);\r\n    if (!nextToken) {\r\n        return false;\r\n    }\r\n    if (prevToken.value === \"(\") {\r\n        if (nextToken.value === \")\") {\r\n            // If the node preceded by a `(` token and followed by a `)` token,\r\n            // then of course it has parentheses.\r\n            return true;\r\n        }\r\n        // If this is one of the few Expression types that can't come first in\r\n        // the enclosing statement because of parsing ambiguities (namely,\r\n        // FunctionExpression, ObjectExpression, and ClassExpression) and\r\n        // this.firstInStatement() returns true, and the node would not need\r\n        // parentheses in an expression context because this.needsParens(true)\r\n        // returns false, then it just needs an opening parenthesis to resolve\r\n        // the parsing ambiguity that made it appear to need parentheses.\r\n        var justNeedsOpeningParen = !this.canBeFirstInStatement() &&\r\n            this.firstInStatement() &&\r\n            !this.needsParens(true);\r\n        if (justNeedsOpeningParen) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\nFPp.getPrevToken = function (node) {\r\n    node = node || this.getNode();\r\n    var loc = node && node.loc;\r\n    var tokens = loc && loc.tokens;\r\n    if (tokens && loc.start.token > 0) {\r\n        var token = tokens[loc.start.token - 1];\r\n        if (token) {\r\n            // Do not return tokens that fall outside the root subtree.\r\n            var rootLoc = this.getRootValue().loc;\r\n            if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {\r\n                return token;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\nFPp.getNextToken = function (node) {\r\n    node = node || this.getNode();\r\n    var loc = node && node.loc;\r\n    var tokens = loc && loc.tokens;\r\n    if (tokens && loc.end.token < tokens.length) {\r\n        var token = tokens[loc.end.token];\r\n        if (token) {\r\n            // Do not return tokens that fall outside the root subtree.\r\n            var rootLoc = this.getRootValue().loc;\r\n            if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {\r\n                return token;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\r\n// more efficient because we're iterating backwards through a stack.\r\nFPp.needsParens = function (assumeExpressionContext) {\r\n    var node = this.getNode();\r\n    // This needs to come before `if (!parent) { return false }` because\r\n    // an object destructuring assignment requires parens for\r\n    // correctness even when it's the topmost expression.\r\n    if (node.type === \"AssignmentExpression\" &&\r\n        node.left.type === \"ObjectPattern\") {\r\n        return true;\r\n    }\r\n    var parent = this.getParentNode();\r\n    if (!parent) {\r\n        return false;\r\n    }\r\n    var name = this.getName();\r\n    // If the value of this path is some child of a Node and not a Node\r\n    // itself, then it doesn't need parentheses. Only Node objects (in fact,\r\n    // only Expression nodes) need parentheses.\r\n    if (this.getValue() !== node) {\r\n        return false;\r\n    }\r\n    // Only statements don't need parentheses.\r\n    if (n.Statement.check(node)) {\r\n        return false;\r\n    }\r\n    // Identifiers never need parentheses.\r\n    if (node.type === \"Identifier\") {\r\n        return false;\r\n    }\r\n    if (parent.type === \"ParenthesizedExpression\" ||\r\n        (node.extra && node.extra.parenthesized)) {\r\n        return false;\r\n    }\r\n    switch (node.type) {\r\n        case \"UnaryExpression\":\r\n        case \"SpreadElement\":\r\n        case \"SpreadProperty\":\r\n            return (parent.type === \"MemberExpression\" &&\r\n                name === \"object\" &&\r\n                parent.object === node);\r\n        case \"BinaryExpression\":\r\n        case \"LogicalExpression\":\r\n            switch (parent.type) {\r\n                case \"CallExpression\":\r\n                    return name === \"callee\" && parent.callee === node;\r\n                case \"UnaryExpression\":\r\n                case \"SpreadElement\":\r\n                case \"SpreadProperty\":\r\n                    return true;\r\n                case \"MemberExpression\":\r\n                    return name === \"object\" && parent.object === node;\r\n                case \"BinaryExpression\":\r\n                case \"LogicalExpression\": {\r\n                    var po = parent.operator;\r\n                    var pp = PRECEDENCE[po];\r\n                    var no = node.operator;\r\n                    var np = PRECEDENCE[no];\r\n                    if (pp > np) {\r\n                        return true;\r\n                    }\r\n                    if (pp === np && name === \"right\") {\r\n                        assert_1.default.strictEqual(parent.right, node);\r\n                        return true;\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    return false;\r\n            }\r\n            break;\r\n        case \"SequenceExpression\":\r\n            switch (parent.type) {\r\n                case \"ReturnStatement\":\r\n                    return false;\r\n                case \"ForStatement\":\r\n                    // Although parentheses wouldn't hurt around sequence expressions in\r\n                    // the head of for loops, traditional style dictates that e.g. i++,\r\n                    // j++ should not be wrapped with parentheses.\r\n                    return false;\r\n                case \"ExpressionStatement\":\r\n                    return name !== \"expression\";\r\n                default:\r\n                    // Otherwise err on the side of overparenthesization, adding\r\n                    // explicit exceptions above if this proves overzealous.\r\n                    return true;\r\n            }\r\n        case \"IntersectionTypeAnnotation\":\r\n        case \"UnionTypeAnnotation\":\r\n            return parent.type === \"NullableTypeAnnotation\";\r\n        case \"Literal\":\r\n            return (parent.type === \"MemberExpression\" &&\r\n                isNumber.check(node.value) &&\r\n                name === \"object\" &&\r\n                parent.object === node);\r\n        // Babel 6 Literal split\r\n        case \"NumericLiteral\":\r\n            return (parent.type === \"MemberExpression\" &&\r\n                name === \"object\" &&\r\n                parent.object === node);\r\n        case \"YieldExpression\":\r\n        case \"AwaitExpression\":\r\n        case \"AssignmentExpression\":\r\n        case \"ConditionalExpression\":\r\n            switch (parent.type) {\r\n                case \"UnaryExpression\":\r\n                case \"SpreadElement\":\r\n                case \"SpreadProperty\":\r\n                case \"BinaryExpression\":\r\n                case \"LogicalExpression\":\r\n                    return true;\r\n                case \"CallExpression\":\r\n                case \"NewExpression\":\r\n                    return name === \"callee\" && parent.callee === node;\r\n                case \"ConditionalExpression\":\r\n                    return name === \"test\" && parent.test === node;\r\n                case \"MemberExpression\":\r\n                    return name === \"object\" && parent.object === node;\r\n                default:\r\n                    return false;\r\n            }\r\n        case \"ArrowFunctionExpression\":\r\n            if (n.CallExpression.check(parent) &&\r\n                name === \"callee\" &&\r\n                parent.callee === node) {\r\n                return true;\r\n            }\r\n            if (n.MemberExpression.check(parent) &&\r\n                name === \"object\" &&\r\n                parent.object === node) {\r\n                return true;\r\n            }\r\n            if (n.TSAsExpression &&\r\n                n.TSAsExpression.check(parent) &&\r\n                name === \"expression\" &&\r\n                parent.expression === node) {\r\n                return true;\r\n            }\r\n            return isBinary(parent);\r\n        case \"ObjectExpression\":\r\n            if (parent.type === \"ArrowFunctionExpression\" &&\r\n                name === \"body\" &&\r\n                parent.body === node) {\r\n                return true;\r\n            }\r\n            break;\r\n        case \"TSAsExpression\":\r\n            if (parent.type === \"ArrowFunctionExpression\" &&\r\n                name === \"body\" &&\r\n                parent.body === node &&\r\n                node.expression.type === \"ObjectExpression\") {\r\n                return true;\r\n            }\r\n            break;\r\n        case \"CallExpression\":\r\n            if (name === \"declaration\" &&\r\n                n.ExportDefaultDeclaration.check(parent) &&\r\n                n.FunctionExpression.check(node.callee)) {\r\n                return true;\r\n            }\r\n    }\r\n    if (parent.type === \"NewExpression\" &&\r\n        name === \"callee\" &&\r\n        parent.callee === node) {\r\n        return containsCallExpression(node);\r\n    }\r\n    if (assumeExpressionContext !== true &&\r\n        !this.canBeFirstInStatement() &&\r\n        this.firstInStatement()) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nfunction isBinary(node) {\r\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\r\n}\r\n// @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\r\nfunction isUnaryLike(node) {\r\n    return (n.UnaryExpression.check(node) ||\r\n        // I considered making SpreadElement and SpreadProperty subtypes of\r\n        // UnaryExpression, but they're not really Expression nodes.\r\n        (n.SpreadElement && n.SpreadElement.check(node)) ||\r\n        (n.SpreadProperty && n.SpreadProperty.check(node)));\r\n}\r\nfunction containsCallExpression(node) {\r\n    if (n.CallExpression.check(node)) {\r\n        return true;\r\n    }\r\n    if (isArray.check(node)) {\r\n        return node.some(containsCallExpression);\r\n    }\r\n    if (n.Node.check(node)) {\r\n        return types.someField(node, function (_name, child) {\r\n            return containsCallExpression(child);\r\n        });\r\n    }\r\n    return false;\r\n}\r\nFPp.canBeFirstInStatement = function () {\r\n    var node = this.getNode();\r\n    if (n.FunctionExpression.check(node)) {\r\n        return false;\r\n    }\r\n    if (n.ObjectExpression.check(node)) {\r\n        return false;\r\n    }\r\n    if (n.ClassExpression.check(node)) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nFPp.firstInStatement = function () {\r\n    var s = this.stack;\r\n    var parentName, parent;\r\n    var childName, child;\r\n    for (var i = s.length - 1; i >= 0; i -= 2) {\r\n        if (n.Node.check(s[i])) {\r\n            childName = parentName;\r\n            child = parent;\r\n            parentName = s[i - 1];\r\n            parent = s[i];\r\n        }\r\n        if (!parent || !child) {\r\n            continue;\r\n        }\r\n        if (n.BlockStatement.check(parent) &&\r\n            parentName === \"body\" &&\r\n            childName === 0) {\r\n            assert_1.default.strictEqual(parent.body[0], child);\r\n            return true;\r\n        }\r\n        if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\r\n            assert_1.default.strictEqual(parent.expression, child);\r\n            return true;\r\n        }\r\n        if (n.AssignmentExpression.check(parent) && childName === \"left\") {\r\n            assert_1.default.strictEqual(parent.left, child);\r\n            return true;\r\n        }\r\n        if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\r\n            assert_1.default.strictEqual(parent.body, child);\r\n            return true;\r\n        }\r\n        if (n.SequenceExpression.check(parent) &&\r\n            parentName === \"expressions\" &&\r\n            childName === 0) {\r\n            assert_1.default.strictEqual(parent.expressions[0], child);\r\n            continue;\r\n        }\r\n        if (n.CallExpression.check(parent) && childName === \"callee\") {\r\n            assert_1.default.strictEqual(parent.callee, child);\r\n            continue;\r\n        }\r\n        if (n.MemberExpression.check(parent) && childName === \"object\") {\r\n            assert_1.default.strictEqual(parent.object, child);\r\n            continue;\r\n        }\r\n        if (n.ConditionalExpression.check(parent) && childName === \"test\") {\r\n            assert_1.default.strictEqual(parent.test, child);\r\n            continue;\r\n        }\r\n        if (isBinary(parent) && childName === \"left\") {\r\n            assert_1.default.strictEqual(parent.left, child);\r\n            continue;\r\n        }\r\n        if (n.UnaryExpression.check(parent) &&\r\n            !parent.prefix &&\r\n            childName === \"argument\") {\r\n            assert_1.default.strictEqual(parent.argument, child);\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.default = FastPath;\r\n"]},"metadata":{},"sourceType":"script"}