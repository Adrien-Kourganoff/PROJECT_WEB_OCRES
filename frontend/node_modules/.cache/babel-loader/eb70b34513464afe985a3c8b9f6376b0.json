{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar Op = Object.prototype;\nvar hasOwn = Op.hasOwnProperty;\n\nfunction pathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var isArray = types.builtInTypes.array;\n  var isNumber = types.builtInTypes.number;\n\n  var Path = function Path(value, parentPath, name) {\n    if (!(this instanceof Path)) {\n      throw new Error(\"Path constructor cannot be invoked without 'new'\");\n    }\n\n    if (parentPath) {\n      if (!(parentPath instanceof Path)) {\n        throw new Error(\"\");\n      }\n    } else {\n      parentPath = null;\n      name = null;\n    } // The value encapsulated by this Path, generally equal to\n    // parentPath.value[name] if we have a parentPath.\n\n\n    this.value = value; // The immediate parent Path of this Path.\n\n    this.parentPath = parentPath; // The name of the property of parentPath.value through which this\n    // Path's value was reached.\n\n    this.name = name; // Calling path.get(\"child\") multiple times always returns the same\n    // child Path object, for both performance and consistency reasons.\n\n    this.__childCache = null;\n  };\n\n  var Pp = Path.prototype;\n\n  function getChildCache(path) {\n    // Lazily create the child cache. This also cheapens cache\n    // invalidation, since you can just reset path.__childCache to null.\n    return path.__childCache || (path.__childCache = Object.create(null));\n  }\n\n  function getChildPath(path, name) {\n    var cache = getChildCache(path);\n    var actualChildValue = path.getValueProperty(name);\n    var childPath = cache[name];\n\n    if (!hasOwn.call(cache, name) || // Ensure consistency between cache and reality.\n    childPath.value !== actualChildValue) {\n      childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n    }\n\n    return childPath;\n  } // This method is designed to be overridden by subclasses that need to\n  // handle missing properties, etc.\n\n\n  Pp.getValueProperty = function getValueProperty(name) {\n    return this.value[name];\n  };\n\n  Pp.get = function get() {\n    var names = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      names[_i] = arguments[_i];\n    }\n\n    var path = this;\n    var count = names.length;\n\n    for (var i = 0; i < count; ++i) {\n      path = getChildPath(path, names[i]);\n    }\n\n    return path;\n  };\n\n  Pp.each = function each(callback, context) {\n    var childPaths = [];\n    var len = this.value.length;\n    var i = 0; // Collect all the original child paths before invoking the callback.\n\n    for (var i = 0; i < len; ++i) {\n      if (hasOwn.call(this.value, i)) {\n        childPaths[i] = this.get(i);\n      }\n    } // Invoke the callback on just the original child paths, regardless of\n    // any modifications made to the array by the callback. I chose these\n    // semantics over cleverly invoking the callback on new elements because\n    // this way is much easier to reason about.\n\n\n    context = context || this;\n\n    for (i = 0; i < len; ++i) {\n      if (hasOwn.call(childPaths, i)) {\n        callback.call(context, childPaths[i]);\n      }\n    }\n  };\n\n  Pp.map = function map(callback, context) {\n    var result = [];\n    this.each(function (childPath) {\n      result.push(callback.call(this, childPath));\n    }, context);\n    return result;\n  };\n\n  Pp.filter = function filter(callback, context) {\n    var result = [];\n    this.each(function (childPath) {\n      if (callback.call(this, childPath)) {\n        result.push(childPath);\n      }\n    }, context);\n    return result;\n  };\n\n  function emptyMoves() {}\n\n  function getMoves(path, offset, start, end) {\n    isArray.assert(path.value);\n\n    if (offset === 0) {\n      return emptyMoves;\n    }\n\n    var length = path.value.length;\n\n    if (length < 1) {\n      return emptyMoves;\n    }\n\n    var argc = arguments.length;\n\n    if (argc === 2) {\n      start = 0;\n      end = length;\n    } else if (argc === 3) {\n      start = Math.max(start, 0);\n      end = length;\n    } else {\n      start = Math.max(start, 0);\n      end = Math.min(end, length);\n    }\n\n    isNumber.assert(start);\n    isNumber.assert(end);\n    var moves = Object.create(null);\n    var cache = getChildCache(path);\n\n    for (var i = start; i < end; ++i) {\n      if (hasOwn.call(path.value, i)) {\n        var childPath = path.get(i);\n\n        if (childPath.name !== i) {\n          throw new Error(\"\");\n        }\n\n        var newIndex = i + offset;\n        childPath.name = newIndex;\n        moves[newIndex] = childPath;\n        delete cache[i];\n      }\n    }\n\n    delete cache.length;\n    return function () {\n      for (var newIndex in moves) {\n        var childPath = moves[newIndex];\n\n        if (childPath.name !== +newIndex) {\n          throw new Error(\"\");\n        }\n\n        cache[newIndex] = childPath;\n        path.value[newIndex] = childPath.value;\n      }\n    };\n  }\n\n  Pp.shift = function shift() {\n    var move = getMoves(this, -1);\n    var result = this.value.shift();\n    move();\n    return result;\n  };\n\n  Pp.unshift = function unshift() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var move = getMoves(this, args.length);\n    var result = this.value.unshift.apply(this.value, args);\n    move();\n    return result;\n  };\n\n  Pp.push = function push() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    isArray.assert(this.value);\n    delete getChildCache(this).length;\n    return this.value.push.apply(this.value, args);\n  };\n\n  Pp.pop = function pop() {\n    isArray.assert(this.value);\n    var cache = getChildCache(this);\n    delete cache[this.value.length - 1];\n    delete cache.length;\n    return this.value.pop();\n  };\n\n  Pp.insertAt = function insertAt(index) {\n    var argc = arguments.length;\n    var move = getMoves(this, argc - 1, index);\n\n    if (move === emptyMoves && argc <= 1) {\n      return this;\n    }\n\n    index = Math.max(index, 0);\n\n    for (var i = 1; i < argc; ++i) {\n      this.value[index + i - 1] = arguments[i];\n    }\n\n    move();\n    return this;\n  };\n\n  Pp.insertBefore = function insertBefore() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name];\n\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n\n  Pp.insertAfter = function insertAfter() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name + 1];\n\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n\n  function repairRelationshipWithParent(path) {\n    if (!(path instanceof Path)) {\n      throw new Error(\"\");\n    }\n\n    var pp = path.parentPath;\n\n    if (!pp) {\n      // Orphan paths have no relationship to repair.\n      return path;\n    }\n\n    var parentValue = pp.value;\n    var parentCache = getChildCache(pp); // Make sure parentCache[path.name] is populated.\n\n    if (parentValue[path.name] === path.value) {\n      parentCache[path.name] = path;\n    } else if (isArray.check(parentValue)) {\n      // Something caused path.name to become out of date, so attempt to\n      // recover by searching for path.value in parentValue.\n      var i = parentValue.indexOf(path.value);\n\n      if (i >= 0) {\n        parentCache[path.name = i] = path;\n      }\n    } else {\n      // If path.value disagrees with parentValue[path.name], and\n      // path.name is not an array index, let path.value become the new\n      // parentValue[path.name] and update parentCache accordingly.\n      parentValue[path.name] = path.value;\n      parentCache[path.name] = path;\n    }\n\n    if (parentValue[path.name] !== path.value) {\n      throw new Error(\"\");\n    }\n\n    if (path.parentPath.get(path.name) !== path) {\n      throw new Error(\"\");\n    }\n\n    return path;\n  }\n\n  Pp.replace = function replace(replacement) {\n    var results = [];\n    var parentValue = this.parentPath.value;\n    var parentCache = getChildCache(this.parentPath);\n    var count = arguments.length;\n    repairRelationshipWithParent(this);\n\n    if (isArray.check(parentValue)) {\n      var originalLength = parentValue.length;\n      var move = getMoves(this.parentPath, count - 1, this.name + 1);\n      var spliceArgs = [this.name, 1];\n\n      for (var i = 0; i < count; ++i) {\n        spliceArgs.push(arguments[i]);\n      }\n\n      var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n\n      if (splicedOut[0] !== this.value) {\n        throw new Error(\"\");\n      }\n\n      if (parentValue.length !== originalLength - 1 + count) {\n        throw new Error(\"\");\n      }\n\n      move();\n\n      if (count === 0) {\n        delete this.value;\n        delete parentCache[this.name];\n        this.__childCache = null;\n      } else {\n        if (parentValue[this.name] !== replacement) {\n          throw new Error(\"\");\n        }\n\n        if (this.value !== replacement) {\n          this.value = replacement;\n          this.__childCache = null;\n        }\n\n        for (i = 0; i < count; ++i) {\n          results.push(this.parentPath.get(this.name + i));\n        }\n\n        if (results[0] !== this) {\n          throw new Error(\"\");\n        }\n      }\n    } else if (count === 1) {\n      if (this.value !== replacement) {\n        this.__childCache = null;\n      }\n\n      this.value = parentValue[this.name] = replacement;\n      results.push(this);\n    } else if (count === 0) {\n      delete parentValue[this.name];\n      delete this.value;\n      this.__childCache = null; // Leave this path cached as parentCache[this.name], even though\n      // it no longer has a value defined.\n    } else {\n      throw new Error(\"Could not replace path\");\n    }\n\n    return results;\n  };\n\n  return Path;\n}\n\nexports.default = pathPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["C:/Users/tara0/OneDrive/Bureau/Travail/Ing 4/Techno web/PROJECT_WEB_OCRES/frontend/node_modules/ast-types/lib/path.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","Op","prototype","hasOwn","hasOwnProperty","pathPlugin","fork","types","use","default","isArray","builtInTypes","array","isNumber","number","Path","parentPath","name","Error","__childCache","Pp","getChildCache","path","create","getChildPath","cache","actualChildValue","getValueProperty","childPath","call","constructor","get","names","_i","arguments","length","count","i","each","callback","context","childPaths","len","map","result","push","filter","emptyMoves","getMoves","offset","start","end","assert","argc","Math","max","min","moves","newIndex","shift","move","unshift","args","apply","pop","insertAt","index","insertBefore","pp","insertAtArgs","insertAfter","repairRelationshipWithParent","parentValue","parentCache","check","indexOf","replace","replacement","results","originalLength","spliceArgs","splicedOut","splice","module"],"mappings":"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","sourcesContent":["\"use strict\";;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\r\nvar Op = Object.prototype;\r\nvar hasOwn = Op.hasOwnProperty;\r\nfunction pathPlugin(fork) {\r\n    var types = fork.use(types_1.default);\r\n    var isArray = types.builtInTypes.array;\r\n    var isNumber = types.builtInTypes.number;\r\n    var Path = function Path(value, parentPath, name) {\r\n        if (!(this instanceof Path)) {\r\n            throw new Error(\"Path constructor cannot be invoked without 'new'\");\r\n        }\r\n        if (parentPath) {\r\n            if (!(parentPath instanceof Path)) {\r\n                throw new Error(\"\");\r\n            }\r\n        }\r\n        else {\r\n            parentPath = null;\r\n            name = null;\r\n        }\r\n        // The value encapsulated by this Path, generally equal to\r\n        // parentPath.value[name] if we have a parentPath.\r\n        this.value = value;\r\n        // The immediate parent Path of this Path.\r\n        this.parentPath = parentPath;\r\n        // The name of the property of parentPath.value through which this\r\n        // Path's value was reached.\r\n        this.name = name;\r\n        // Calling path.get(\"child\") multiple times always returns the same\r\n        // child Path object, for both performance and consistency reasons.\r\n        this.__childCache = null;\r\n    };\r\n    var Pp = Path.prototype;\r\n    function getChildCache(path) {\r\n        // Lazily create the child cache. This also cheapens cache\r\n        // invalidation, since you can just reset path.__childCache to null.\r\n        return path.__childCache || (path.__childCache = Object.create(null));\r\n    }\r\n    function getChildPath(path, name) {\r\n        var cache = getChildCache(path);\r\n        var actualChildValue = path.getValueProperty(name);\r\n        var childPath = cache[name];\r\n        if (!hasOwn.call(cache, name) ||\r\n            // Ensure consistency between cache and reality.\r\n            childPath.value !== actualChildValue) {\r\n            childPath = cache[name] = new path.constructor(actualChildValue, path, name);\r\n        }\r\n        return childPath;\r\n    }\r\n    // This method is designed to be overridden by subclasses that need to\r\n    // handle missing properties, etc.\r\n    Pp.getValueProperty = function getValueProperty(name) {\r\n        return this.value[name];\r\n    };\r\n    Pp.get = function get() {\r\n        var names = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            names[_i] = arguments[_i];\r\n        }\r\n        var path = this;\r\n        var count = names.length;\r\n        for (var i = 0; i < count; ++i) {\r\n            path = getChildPath(path, names[i]);\r\n        }\r\n        return path;\r\n    };\r\n    Pp.each = function each(callback, context) {\r\n        var childPaths = [];\r\n        var len = this.value.length;\r\n        var i = 0;\r\n        // Collect all the original child paths before invoking the callback.\r\n        for (var i = 0; i < len; ++i) {\r\n            if (hasOwn.call(this.value, i)) {\r\n                childPaths[i] = this.get(i);\r\n            }\r\n        }\r\n        // Invoke the callback on just the original child paths, regardless of\r\n        // any modifications made to the array by the callback. I chose these\r\n        // semantics over cleverly invoking the callback on new elements because\r\n        // this way is much easier to reason about.\r\n        context = context || this;\r\n        for (i = 0; i < len; ++i) {\r\n            if (hasOwn.call(childPaths, i)) {\r\n                callback.call(context, childPaths[i]);\r\n            }\r\n        }\r\n    };\r\n    Pp.map = function map(callback, context) {\r\n        var result = [];\r\n        this.each(function (childPath) {\r\n            result.push(callback.call(this, childPath));\r\n        }, context);\r\n        return result;\r\n    };\r\n    Pp.filter = function filter(callback, context) {\r\n        var result = [];\r\n        this.each(function (childPath) {\r\n            if (callback.call(this, childPath)) {\r\n                result.push(childPath);\r\n            }\r\n        }, context);\r\n        return result;\r\n    };\r\n    function emptyMoves() { }\r\n    function getMoves(path, offset, start, end) {\r\n        isArray.assert(path.value);\r\n        if (offset === 0) {\r\n            return emptyMoves;\r\n        }\r\n        var length = path.value.length;\r\n        if (length < 1) {\r\n            return emptyMoves;\r\n        }\r\n        var argc = arguments.length;\r\n        if (argc === 2) {\r\n            start = 0;\r\n            end = length;\r\n        }\r\n        else if (argc === 3) {\r\n            start = Math.max(start, 0);\r\n            end = length;\r\n        }\r\n        else {\r\n            start = Math.max(start, 0);\r\n            end = Math.min(end, length);\r\n        }\r\n        isNumber.assert(start);\r\n        isNumber.assert(end);\r\n        var moves = Object.create(null);\r\n        var cache = getChildCache(path);\r\n        for (var i = start; i < end; ++i) {\r\n            if (hasOwn.call(path.value, i)) {\r\n                var childPath = path.get(i);\r\n                if (childPath.name !== i) {\r\n                    throw new Error(\"\");\r\n                }\r\n                var newIndex = i + offset;\r\n                childPath.name = newIndex;\r\n                moves[newIndex] = childPath;\r\n                delete cache[i];\r\n            }\r\n        }\r\n        delete cache.length;\r\n        return function () {\r\n            for (var newIndex in moves) {\r\n                var childPath = moves[newIndex];\r\n                if (childPath.name !== +newIndex) {\r\n                    throw new Error(\"\");\r\n                }\r\n                cache[newIndex] = childPath;\r\n                path.value[newIndex] = childPath.value;\r\n            }\r\n        };\r\n    }\r\n    Pp.shift = function shift() {\r\n        var move = getMoves(this, -1);\r\n        var result = this.value.shift();\r\n        move();\r\n        return result;\r\n    };\r\n    Pp.unshift = function unshift() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var move = getMoves(this, args.length);\r\n        var result = this.value.unshift.apply(this.value, args);\r\n        move();\r\n        return result;\r\n    };\r\n    Pp.push = function push() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        isArray.assert(this.value);\r\n        delete getChildCache(this).length;\r\n        return this.value.push.apply(this.value, args);\r\n    };\r\n    Pp.pop = function pop() {\r\n        isArray.assert(this.value);\r\n        var cache = getChildCache(this);\r\n        delete cache[this.value.length - 1];\r\n        delete cache.length;\r\n        return this.value.pop();\r\n    };\r\n    Pp.insertAt = function insertAt(index) {\r\n        var argc = arguments.length;\r\n        var move = getMoves(this, argc - 1, index);\r\n        if (move === emptyMoves && argc <= 1) {\r\n            return this;\r\n        }\r\n        index = Math.max(index, 0);\r\n        for (var i = 1; i < argc; ++i) {\r\n            this.value[index + i - 1] = arguments[i];\r\n        }\r\n        move();\r\n        return this;\r\n    };\r\n    Pp.insertBefore = function insertBefore() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var pp = this.parentPath;\r\n        var argc = args.length;\r\n        var insertAtArgs = [this.name];\r\n        for (var i = 0; i < argc; ++i) {\r\n            insertAtArgs.push(args[i]);\r\n        }\r\n        return pp.insertAt.apply(pp, insertAtArgs);\r\n    };\r\n    Pp.insertAfter = function insertAfter() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var pp = this.parentPath;\r\n        var argc = args.length;\r\n        var insertAtArgs = [this.name + 1];\r\n        for (var i = 0; i < argc; ++i) {\r\n            insertAtArgs.push(args[i]);\r\n        }\r\n        return pp.insertAt.apply(pp, insertAtArgs);\r\n    };\r\n    function repairRelationshipWithParent(path) {\r\n        if (!(path instanceof Path)) {\r\n            throw new Error(\"\");\r\n        }\r\n        var pp = path.parentPath;\r\n        if (!pp) {\r\n            // Orphan paths have no relationship to repair.\r\n            return path;\r\n        }\r\n        var parentValue = pp.value;\r\n        var parentCache = getChildCache(pp);\r\n        // Make sure parentCache[path.name] is populated.\r\n        if (parentValue[path.name] === path.value) {\r\n            parentCache[path.name] = path;\r\n        }\r\n        else if (isArray.check(parentValue)) {\r\n            // Something caused path.name to become out of date, so attempt to\r\n            // recover by searching for path.value in parentValue.\r\n            var i = parentValue.indexOf(path.value);\r\n            if (i >= 0) {\r\n                parentCache[path.name = i] = path;\r\n            }\r\n        }\r\n        else {\r\n            // If path.value disagrees with parentValue[path.name], and\r\n            // path.name is not an array index, let path.value become the new\r\n            // parentValue[path.name] and update parentCache accordingly.\r\n            parentValue[path.name] = path.value;\r\n            parentCache[path.name] = path;\r\n        }\r\n        if (parentValue[path.name] !== path.value) {\r\n            throw new Error(\"\");\r\n        }\r\n        if (path.parentPath.get(path.name) !== path) {\r\n            throw new Error(\"\");\r\n        }\r\n        return path;\r\n    }\r\n    Pp.replace = function replace(replacement) {\r\n        var results = [];\r\n        var parentValue = this.parentPath.value;\r\n        var parentCache = getChildCache(this.parentPath);\r\n        var count = arguments.length;\r\n        repairRelationshipWithParent(this);\r\n        if (isArray.check(parentValue)) {\r\n            var originalLength = parentValue.length;\r\n            var move = getMoves(this.parentPath, count - 1, this.name + 1);\r\n            var spliceArgs = [this.name, 1];\r\n            for (var i = 0; i < count; ++i) {\r\n                spliceArgs.push(arguments[i]);\r\n            }\r\n            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\r\n            if (splicedOut[0] !== this.value) {\r\n                throw new Error(\"\");\r\n            }\r\n            if (parentValue.length !== (originalLength - 1 + count)) {\r\n                throw new Error(\"\");\r\n            }\r\n            move();\r\n            if (count === 0) {\r\n                delete this.value;\r\n                delete parentCache[this.name];\r\n                this.__childCache = null;\r\n            }\r\n            else {\r\n                if (parentValue[this.name] !== replacement) {\r\n                    throw new Error(\"\");\r\n                }\r\n                if (this.value !== replacement) {\r\n                    this.value = replacement;\r\n                    this.__childCache = null;\r\n                }\r\n                for (i = 0; i < count; ++i) {\r\n                    results.push(this.parentPath.get(this.name + i));\r\n                }\r\n                if (results[0] !== this) {\r\n                    throw new Error(\"\");\r\n                }\r\n            }\r\n        }\r\n        else if (count === 1) {\r\n            if (this.value !== replacement) {\r\n                this.__childCache = null;\r\n            }\r\n            this.value = parentValue[this.name] = replacement;\r\n            results.push(this);\r\n        }\r\n        else if (count === 0) {\r\n            delete parentValue[this.name];\r\n            delete this.value;\r\n            this.__childCache = null;\r\n            // Leave this path cached as parentCache[this.name], even though\r\n            // it no longer has a value defined.\r\n        }\r\n        else {\r\n            throw new Error(\"Could not replace path\");\r\n        }\r\n        return results;\r\n    };\r\n    return Path;\r\n}\r\nexports.default = pathPlugin;\r\nmodule.exports = exports[\"default\"];\r\n"]},"metadata":{},"sourceType":"script"}