{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nconst Collection = require('../Collection');\n\nconst NodeCollection = require('./Node');\n\nconst once = require('../utils/once');\n\nconst recast = require('recast');\n\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\nconst b = recast.types.builders;\nvar types = recast.types.namedTypes;\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\n/**\r\n* @mixin\r\n*/\n\nconst globalMethods = {\n  /**\r\n   * Finds all variable declarators, optionally filtered by name.\r\n   *\r\n   * @param {string} name\r\n   * @return {Collection}\r\n   */\n  findVariableDeclarators: function (name) {\n    const filter = name ? {\n      id: {\n        name: name\n      }\n    } : null;\n    return this.find(VariableDeclarator, filter);\n  }\n};\nconst filterMethods = {\n  /**\r\n   * Returns a function that returns true if the provided path is a variable\r\n   * declarator and requires one of the specified module names.\r\n   *\r\n   * @param {string|Array} names A module name or an array of module names\r\n   * @return {Function}\r\n   */\n  requiresModule: function (names) {\n    if (names && !Array.isArray(names)) {\n      names = [names];\n    }\n\n    const requireIdentifier = b.identifier('require');\n    return function (path) {\n      const node = path.value;\n\n      if (!VariableDeclarator.check(node) || !types.CallExpression.check(node.init) || !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\n        return false;\n      }\n\n      return !names || names.some(n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n)));\n    };\n  }\n};\n/**\r\n* @mixin\r\n*/\n\nconst transformMethods = {\n  /**\r\n   * Renames a variable and all its occurrences.\r\n   *\r\n   * @param {string} newName\r\n   * @return {Collection}\r\n   */\n  renameTo: function (newName) {\n    // TODO: Include JSXElements\n    return this.forEach(function (path) {\n      const node = path.value;\n      const oldName = node.id.name;\n      const rootScope = path.scope;\n      const rootPath = rootScope.path;\n      Collection.fromPaths([rootPath]).find(types.Identifier, {\n        name: oldName\n      }).filter(function (path) {\n        // ignore non-variables\n        const parent = path.parent.node;\n\n        if (types.MemberExpression.check(parent) && parent.property === path.node && !parent.computed) {\n          // obj.oldName\n          return false;\n        }\n\n        if (types.Property.check(parent) && parent.key === path.node && !parent.computed) {\n          // { oldName: 3 }\n          return false;\n        }\n\n        if (types.MethodDefinition.check(parent) && parent.key === path.node && !parent.computed) {\n          // class A { oldName() {} }\n          return false;\n        }\n\n        if (types.ClassProperty.check(parent) && parent.key === path.node && !parent.computed) {\n          // class A { oldName = 3 }\n          return false;\n        }\n\n        if (types.JSXAttribute.check(parent) && parent.name === path.node && !parent.computed) {\n          // <Foo oldName={oldName} />\n          return false;\n        }\n\n        return true;\n      }).forEach(function (path) {\n        let scope = path.scope;\n\n        while (scope && scope !== rootScope) {\n          if (scope.declares(oldName)) {\n            return;\n          }\n\n          scope = scope.parent;\n        }\n\n        if (scope) {\n          // identifier must refer to declared variable\n          // It may look like we filtered out properties,\n          // but the filter only ignored property \"keys\", not \"value\"s\n          // In shorthand properties, \"key\" and \"value\" both have an\n          // Identifier with the same structure.\n          const parent = path.parent.node;\n\n          if (types.Property.check(parent) && parent.shorthand && !parent.method) {\n            path.parent.get('shorthand').replace(false);\n          }\n\n          path.get('name').replace(newName);\n        }\n      });\n    });\n  }\n};\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods);\n  Collection.registerMethods(transformMethods, VariableDeclarator);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;","map":{"version":3,"sources":["C:/Users/tara0/OneDrive/Bureau/Travail/Ing 4/Techno web/PROJECT_WEB_OCRES/frontend/node_modules/jscodeshift/src/collections/VariableDeclarator.js"],"names":["Collection","require","NodeCollection","once","recast","astNodesAreEquivalent","types","b","builders","namedTypes","VariableDeclarator","globalMethods","findVariableDeclarators","name","filter","id","find","filterMethods","requiresModule","names","Array","isArray","requireIdentifier","identifier","path","node","value","check","CallExpression","init","callee","some","n","arguments","literal","transformMethods","renameTo","newName","forEach","oldName","rootScope","scope","rootPath","fromPaths","Identifier","parent","MemberExpression","property","computed","Property","key","MethodDefinition","ClassProperty","JSXAttribute","declares","shorthand","method","get","replace","register","registerMethods","exports","filters"],"mappings":"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","sourcesContent":["\r\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nconst Collection = require('../Collection');\r\nconst NodeCollection = require('./Node');\r\nconst once = require('../utils/once');\r\nconst recast = require('recast');\r\n\r\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\r\nconst b = recast.types.builders;\r\nvar types = recast.types.namedTypes;\r\n\r\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\r\n\r\n/**\r\n* @mixin\r\n*/\r\nconst globalMethods = {\r\n  /**\r\n   * Finds all variable declarators, optionally filtered by name.\r\n   *\r\n   * @param {string} name\r\n   * @return {Collection}\r\n   */\r\n  findVariableDeclarators: function(name) {\r\n    const filter = name ? {id: {name: name}} : null;\r\n    return this.find(VariableDeclarator, filter);\r\n  }\r\n};\r\n\r\nconst filterMethods = {\r\n  /**\r\n   * Returns a function that returns true if the provided path is a variable\r\n   * declarator and requires one of the specified module names.\r\n   *\r\n   * @param {string|Array} names A module name or an array of module names\r\n   * @return {Function}\r\n   */\r\n  requiresModule: function(names) {\r\n    if (names && !Array.isArray(names)) {\r\n      names = [names];\r\n    }\r\n    const requireIdentifier = b.identifier('require');\r\n    return function(path) {\r\n      const node = path.value;\r\n      if (!VariableDeclarator.check(node) ||\r\n          !types.CallExpression.check(node.init) ||\r\n          !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\r\n        return false;\r\n      }\r\n      return !names ||\r\n        names.some(\r\n          n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n))\r\n        );\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n* @mixin\r\n*/\r\nconst transformMethods = {\r\n  /**\r\n   * Renames a variable and all its occurrences.\r\n   *\r\n   * @param {string} newName\r\n   * @return {Collection}\r\n   */\r\n  renameTo: function(newName) {\r\n    // TODO: Include JSXElements\r\n    return this.forEach(function(path) {\r\n      const node = path.value;\r\n      const oldName = node.id.name;\r\n      const rootScope = path.scope;\r\n      const rootPath = rootScope.path;\r\n      Collection.fromPaths([rootPath])\r\n        .find(types.Identifier, {name: oldName})\r\n        .filter(function(path) { // ignore non-variables\r\n          const parent = path.parent.node;\r\n\r\n          if (\r\n            types.MemberExpression.check(parent) &&\r\n            parent.property === path.node &&\r\n            !parent.computed\r\n          ) {\r\n            // obj.oldName\r\n            return false;\r\n          }\r\n\r\n          if (\r\n            types.Property.check(parent) &&\r\n            parent.key === path.node &&\r\n            !parent.computed\r\n          ) {\r\n            // { oldName: 3 }\r\n            return false;\r\n          }\r\n\r\n          if (\r\n            types.MethodDefinition.check(parent) &&\r\n            parent.key === path.node &&\r\n            !parent.computed\r\n          ) {\r\n            // class A { oldName() {} }\r\n            return false;\r\n          }\r\n\r\n          if (\r\n            types.ClassProperty.check(parent) &&\r\n            parent.key === path.node &&\r\n            !parent.computed\r\n          ) {\r\n            // class A { oldName = 3 }\r\n            return false;\r\n          }\r\n\r\n          if (\r\n            types.JSXAttribute.check(parent) &&\r\n            parent.name === path.node &&\r\n            !parent.computed\r\n          ) {\r\n            // <Foo oldName={oldName} />\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        })\r\n        .forEach(function(path) {\r\n          let scope = path.scope;\r\n          while (scope && scope !== rootScope) {\r\n            if (scope.declares(oldName)) {\r\n              return;\r\n            }\r\n            scope = scope.parent;\r\n          }\r\n          if (scope) { // identifier must refer to declared variable\r\n\r\n            // It may look like we filtered out properties,\r\n            // but the filter only ignored property \"keys\", not \"value\"s\r\n            // In shorthand properties, \"key\" and \"value\" both have an\r\n            // Identifier with the same structure.\r\n            const parent = path.parent.node;\r\n            if (\r\n              types.Property.check(parent) &&\r\n              parent.shorthand &&\r\n              !parent.method\r\n            )  {\r\n\r\n              path.parent.get('shorthand').replace(false);\r\n            }\r\n\r\n            path.get('name').replace(newName);\r\n          }\r\n        });\r\n    });\r\n  }\r\n};\r\n\r\n\r\nfunction register() {\r\n  NodeCollection.register();\r\n  Collection.registerMethods(globalMethods);\r\n  Collection.registerMethods(transformMethods, VariableDeclarator);\r\n}\r\n\r\nexports.register = once(register);\r\nexports.filters = filterMethods;\r\n"]},"metadata":{},"sourceType":"script"}