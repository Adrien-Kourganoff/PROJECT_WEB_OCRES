{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nconst assert = require('assert');\n\nconst intersection = require('./utils/intersection');\n\nconst recast = require('recast');\n\nconst union = require('./utils/union');\n\nconst astTypes = recast.types;\nvar types = astTypes.namedTypes;\nconst NodePath = astTypes.NodePath;\nconst Node = types.Node;\n/**\r\n * This represents a generic collection of node paths. It only has a generic\r\n * API to access and process the elements of the list. It doesn't know anything\r\n * about AST types.\r\n *\r\n * @mixes traversalMethods\r\n * @mixes mutationMethods\r\n * @mixes transformMethods\r\n * @mixes globalMethods\r\n */\n\nclass Collection {\n  /**\r\n   * @param {Array} paths An array of AST paths\r\n   * @param {Collection} parent A parent collection\r\n   * @param {Array} types An array of types all the paths in the collection\r\n   *  have in common. If not passed, it will be inferred from the paths.\r\n   * @return {Collection}\r\n   */\n  constructor(paths, parent, types) {\n    assert.ok(Array.isArray(paths), 'Collection is passed an array');\n    assert.ok(paths.every(p => p instanceof NodePath), 'Array contains only paths');\n    this._parent = parent;\n    this.__paths = paths;\n\n    if (types && !Array.isArray(types)) {\n      types = _toTypeArray(types);\n    } else if (!types || Array.isArray(types) && types.length === 0) {\n      types = _inferTypes(paths);\n    }\n\n    this._types = types.length === 0 ? _defaultType : types;\n  }\n  /**\r\n   * Returns a new collection containing the nodes for which the callback\r\n   * returns true.\r\n   *\r\n   * @param {function} callback\r\n   * @return {Collection}\r\n   */\n\n\n  filter(callback) {\n    return new this.constructor(this.__paths.filter(callback), this);\n  }\n  /**\r\n   * Executes callback for each node/path in the collection.\r\n   *\r\n   * @param {function} callback\r\n   * @return {Collection} The collection itself\r\n   */\n\n\n  forEach(callback) {\n    this.__paths.forEach((path, i, paths) => callback.call(path, path, i, paths));\n\n    return this;\n  }\n  /**\r\n   * Tests whether at-least one path passes the test implemented by the provided callback.\r\n   *\r\n   * @param {function} callback\r\n   * @return {boolean}\r\n   */\n\n\n  some(callback) {\n    return this.__paths.some((path, i, paths) => callback.call(path, path, i, paths));\n  }\n  /**\r\n   * Tests whether all paths pass the test implemented by the provided callback.\r\n   *\r\n   * @param {function} callback\r\n   * @return {boolean}\r\n   */\n\n\n  every(callback) {\n    return this.__paths.every((path, i, paths) => callback.call(path, path, i, paths));\n  }\n  /**\r\n   * Executes the callback for every path in the collection and returns a new\r\n   * collection from the return values (which must be paths).\r\n   *\r\n   * The callback can return null to indicate to exclude the element from the\r\n   * new collection.\r\n   *\r\n   * If an array is returned, the array will be flattened into the result\r\n   * collection.\r\n   *\r\n   * @param {function} callback\r\n   * @param {Type} type Force the new collection to be of a specific type\r\n   */\n\n\n  map(callback, type) {\n    const paths = [];\n    this.forEach(function (path) {\n      /*jshint eqnull:true*/\n      let result = callback.apply(path, arguments);\n      if (result == null) return;\n\n      if (!Array.isArray(result)) {\n        result = [result];\n      }\n\n      for (let i = 0; i < result.length; i++) {\n        if (paths.indexOf(result[i]) === -1) {\n          paths.push(result[i]);\n        }\n      }\n    });\n    return fromPaths(paths, this, type);\n  }\n  /**\r\n   * Returns the number of elements in this collection.\r\n   *\r\n   * @return {number}\r\n   */\n\n\n  size() {\n    return this.__paths.length;\n  }\n  /**\r\n   * Returns the number of elements in this collection.\r\n   *\r\n   * @return {number}\r\n   */\n\n\n  get length() {\n    return this.__paths.length;\n  }\n  /**\r\n   * Returns an array of AST nodes in this collection.\r\n   *\r\n   * @return {Array}\r\n   */\n\n\n  nodes() {\n    return this.__paths.map(p => p.value);\n  }\n\n  paths() {\n    return this.__paths;\n  }\n\n  getAST() {\n    if (this._parent) {\n      return this._parent.getAST();\n    }\n\n    return this.__paths;\n  }\n\n  toSource(options) {\n    if (this._parent) {\n      return this._parent.toSource(options);\n    }\n\n    if (this.__paths.length === 1) {\n      return recast.print(this.__paths[0], options).code;\n    } else {\n      return this.__paths.map(p => recast.print(p, options).code);\n    }\n  }\n  /**\r\n   * Returns a new collection containing only the element at position index.\r\n   *\r\n   * In case of a negative index, the element is taken from the end:\r\n   *\r\n   *   .at(0)  - first element\r\n   *   .at(-1) - last element\r\n   *\r\n   * @param {number} index\r\n   * @return {Collection}\r\n   */\n\n\n  at(index) {\n    return fromPaths(this.__paths.slice(index, index === -1 ? undefined : index + 1), this);\n  }\n  /**\r\n   * Proxies to NodePath#get of the first path.\r\n   *\r\n   * @param {string|number} ...fields\r\n   */\n\n\n  get() {\n    const path = this.__paths[0];\n\n    if (!path) {\n      throw Error('You cannot call \"get\" on a collection with no paths. ' + 'Instead, check the \"length\" property first to verify at least 1 path exists.');\n    }\n\n    return path.get.apply(path, arguments);\n  }\n  /**\r\n   * Returns the type(s) of the collection. This is only used for unit tests,\r\n   * I don't think other consumers would need it.\r\n   *\r\n   * @return {Array<string>}\r\n   */\n\n\n  getTypes() {\n    return this._types;\n  }\n  /**\r\n   * Returns true if this collection has the type 'type'.\r\n   *\r\n   * @param {Type} type\r\n   * @return {boolean}\r\n   */\n\n\n  isOfType(type) {\n    return !!type && this._types.indexOf(type.toString()) > -1;\n  }\n\n}\n/**\r\n * Given a set of paths, this infers the common types of all paths.\r\n * @private\r\n * @param {Array} paths An array of paths.\r\n * @return {Type} type An AST type\r\n */\n\n\nfunction _inferTypes(paths) {\n  let _types = [];\n\n  if (paths.length > 0 && Node.check(paths[0].node)) {\n    const nodeType = types[paths[0].node.type];\n    const sameType = paths.length === 1 || paths.every(path => nodeType.check(path.node));\n\n    if (sameType) {\n      _types = [nodeType.toString()].concat(astTypes.getSupertypeNames(nodeType.toString()));\n    } else {\n      // try to find a common type\n      _types = intersection(paths.map(path => astTypes.getSupertypeNames(path.node.type)));\n    }\n  }\n\n  return _types;\n}\n\nfunction _toTypeArray(value) {\n  value = !Array.isArray(value) ? [value] : value;\n  value = value.map(v => v.toString());\n\n  if (value.length > 1) {\n    return union([value].concat(intersection(value.map(_getSupertypeNames))));\n  } else {\n    return value.concat(_getSupertypeNames(value[0]));\n  }\n}\n\nfunction _getSupertypeNames(type) {\n  try {\n    return astTypes.getSupertypeNames(type);\n  } catch (error) {\n    if (error.message === '') {\n      // Likely the case that the passed type wasn't found in the definition\n      // list. Maybe a typo. ast-types doesn't throw a useful error in that\n      // case :(\n      throw new Error('\"' + type + '\" is not a known AST node type. Maybe a typo?');\n    }\n\n    throw error;\n  }\n}\n/**\r\n * Creates a new collection from an array of node paths.\r\n *\r\n * If type is passed, it will create a typed collection if such a collection\r\n * exists. The nodes or path values must be of the same type.\r\n *\r\n * Otherwise it will try to infer the type from the path list. If every\r\n * element has the same type, a typed collection is created (if it exists),\r\n * otherwise, a generic collection will be created.\r\n *\r\n * @ignore\r\n * @param {Array} paths An array of paths\r\n * @param {Collection} parent A parent collection\r\n * @param {Type} type An AST type\r\n * @return {Collection}\r\n */\n\n\nfunction fromPaths(paths, parent, type) {\n  assert.ok(paths.every(n => n instanceof NodePath), 'Every element in the array should be a NodePath');\n  return new Collection(paths, parent, type);\n}\n/**\r\n * Creates a new collection from an array of nodes. This is a convenience\r\n * method which converts the nodes to node paths first and calls\r\n *\r\n *    Collections.fromPaths(paths, parent, type)\r\n *\r\n * @ignore\r\n * @param {Array} nodes An array of AST nodes\r\n * @param {Collection} parent A parent collection\r\n * @param {Type} type An AST type\r\n * @return {Collection}\r\n */\n\n\nfunction fromNodes(nodes, parent, type) {\n  assert.ok(nodes.every(n => Node.check(n)), 'Every element in the array should be a Node');\n  return fromPaths(nodes.map(n => new NodePath(n)), parent, type);\n}\n\nconst CPt = Collection.prototype;\n/**\r\n * This function adds the provided methods to the prototype of the corresponding\r\n * typed collection. If no type is passed, the methods are added to\r\n * Collection.prototype and are available for all collections.\r\n *\r\n * @param {Object} methods Methods to add to the prototype\r\n * @param {Type=} type Optional type to add the methods to\r\n */\n\nfunction registerMethods(methods, type) {\n  for (const methodName in methods) {\n    if (!methods.hasOwnProperty(methodName)) {\n      return;\n    }\n\n    if (hasConflictingRegistration(methodName, type)) {\n      let msg = `There is a conflicting registration for method with name \"${methodName}\".\\nYou tried to register an additional method with `;\n\n      if (type) {\n        msg += `type \"${type.toString()}\".`;\n      } else {\n        msg += 'universal type.';\n      }\n\n      msg += '\\nThere are existing registrations for that method with ';\n      const conflictingRegistrations = CPt[methodName].typedRegistrations;\n\n      if (conflictingRegistrations) {\n        msg += `type ${Object.keys(conflictingRegistrations).join(', ')}.`;\n      } else {\n        msg += 'universal type.';\n      }\n\n      throw Error(msg);\n    }\n\n    if (!type) {\n      CPt[methodName] = methods[methodName];\n    } else {\n      type = type.toString();\n\n      if (!CPt.hasOwnProperty(methodName)) {\n        installTypedMethod(methodName);\n      }\n\n      var registrations = CPt[methodName].typedRegistrations;\n      registrations[type] = methods[methodName];\n      astTypes.getSupertypeNames(type).forEach(function (name) {\n        registrations[name] = false;\n      });\n    }\n  }\n}\n\nfunction installTypedMethod(methodName) {\n  if (CPt.hasOwnProperty(methodName)) {\n    throw new Error(`Internal Error: \"${methodName}\" method is already installed`);\n  }\n\n  const registrations = {};\n\n  function typedMethod() {\n    const types = Object.keys(registrations);\n\n    for (let i = 0; i < types.length; i++) {\n      const currentType = types[i];\n\n      if (registrations[currentType] && this.isOfType(currentType)) {\n        return registrations[currentType].apply(this, arguments);\n      }\n    }\n\n    throw Error(`You have a collection of type [${this.getTypes()}]. ` + `\"${methodName}\" is only defined for one of [${types.join('|')}].`);\n  }\n\n  typedMethod.typedRegistrations = registrations;\n  CPt[methodName] = typedMethod;\n}\n\nfunction hasConflictingRegistration(methodName, type) {\n  if (!type) {\n    return CPt.hasOwnProperty(methodName);\n  }\n\n  if (!CPt.hasOwnProperty(methodName)) {\n    return false;\n  }\n\n  const registrations = CPt[methodName] && CPt[methodName].typedRegistrations;\n\n  if (!registrations) {\n    return true;\n  }\n\n  type = type.toString();\n\n  if (registrations.hasOwnProperty(type)) {\n    return true;\n  }\n\n  return astTypes.getSupertypeNames(type.toString()).some(function (name) {\n    return !!registrations[name];\n  });\n}\n\nvar _defaultType = [];\n/**\r\n * Sets the default collection type. In case a collection is created form an\r\n * empty set of paths and no type is specified, we return a collection of this\r\n * type.\r\n *\r\n * @ignore\r\n * @param {Type} type\r\n */\n\nfunction setDefaultCollectionType(type) {\n  _defaultType = _toTypeArray(type);\n}\n\nexports.fromPaths = fromPaths;\nexports.fromNodes = fromNodes;\nexports.registerMethods = registerMethods;\nexports.hasConflictingRegistration = hasConflictingRegistration;\nexports.setDefaultCollectionType = setDefaultCollectionType;","map":{"version":3,"sources":["C:/Users/tara0/OneDrive/Bureau/Travail/Ing 4/Techno web/PROJECT_WEB_OCRES/frontend/node_modules/jscodeshift/src/Collection.js"],"names":["assert","require","intersection","recast","union","astTypes","types","namedTypes","NodePath","Node","Collection","constructor","paths","parent","ok","Array","isArray","every","p","_parent","__paths","_toTypeArray","length","_inferTypes","_types","_defaultType","filter","callback","forEach","path","i","call","some","map","type","result","apply","arguments","indexOf","push","fromPaths","size","nodes","value","getAST","toSource","options","print","code","at","index","slice","undefined","get","Error","getTypes","isOfType","toString","check","node","nodeType","sameType","concat","getSupertypeNames","v","_getSupertypeNames","error","message","n","fromNodes","CPt","prototype","registerMethods","methods","methodName","hasOwnProperty","hasConflictingRegistration","msg","conflictingRegistrations","typedRegistrations","Object","keys","join","installTypedMethod","registrations","name","typedMethod","currentType","setDefaultCollectionType","exports"],"mappings":"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","sourcesContent":["\r\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nconst assert = require('assert');\r\nconst intersection = require('./utils/intersection');\r\nconst recast = require('recast');\r\nconst union = require('./utils/union');\r\n\r\nconst astTypes = recast.types;\r\nvar types = astTypes.namedTypes;\r\nconst NodePath = astTypes.NodePath;\r\nconst Node = types.Node;\r\n\r\n/**\r\n * This represents a generic collection of node paths. It only has a generic\r\n * API to access and process the elements of the list. It doesn't know anything\r\n * about AST types.\r\n *\r\n * @mixes traversalMethods\r\n * @mixes mutationMethods\r\n * @mixes transformMethods\r\n * @mixes globalMethods\r\n */\r\nclass Collection {\r\n\r\n  /**\r\n   * @param {Array} paths An array of AST paths\r\n   * @param {Collection} parent A parent collection\r\n   * @param {Array} types An array of types all the paths in the collection\r\n   *  have in common. If not passed, it will be inferred from the paths.\r\n   * @return {Collection}\r\n   */\r\n  constructor(paths, parent, types) {\r\n    assert.ok(Array.isArray(paths), 'Collection is passed an array');\r\n    assert.ok(\r\n      paths.every(p => p instanceof NodePath),\r\n      'Array contains only paths'\r\n    );\r\n    this._parent = parent;\r\n    this.__paths = paths;\r\n    if (types && !Array.isArray(types)) {\r\n      types = _toTypeArray(types);\r\n    } else if (!types || Array.isArray(types) && types.length === 0) {\r\n      types = _inferTypes(paths);\r\n    }\r\n    this._types = types.length === 0 ? _defaultType : types;\r\n  }\r\n\r\n  /**\r\n   * Returns a new collection containing the nodes for which the callback\r\n   * returns true.\r\n   *\r\n   * @param {function} callback\r\n   * @return {Collection}\r\n   */\r\n  filter(callback) {\r\n    return new this.constructor(this.__paths.filter(callback), this);\r\n  }\r\n\r\n  /**\r\n   * Executes callback for each node/path in the collection.\r\n   *\r\n   * @param {function} callback\r\n   * @return {Collection} The collection itself\r\n   */\r\n  forEach(callback) {\r\n    this.__paths.forEach(\r\n      (path, i, paths) => callback.call(path, path, i, paths)\r\n    );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Tests whether at-least one path passes the test implemented by the provided callback.\r\n   *\r\n   * @param {function} callback\r\n   * @return {boolean}\r\n   */\r\n  some(callback) {\r\n    return this.__paths.some(\r\n      (path, i, paths) => callback.call(path, path, i, paths)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Tests whether all paths pass the test implemented by the provided callback.\r\n   *\r\n   * @param {function} callback\r\n   * @return {boolean}\r\n   */\r\n  every(callback) {\r\n    return this.__paths.every(\r\n      (path, i, paths) => callback.call(path, path, i, paths)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Executes the callback for every path in the collection and returns a new\r\n   * collection from the return values (which must be paths).\r\n   *\r\n   * The callback can return null to indicate to exclude the element from the\r\n   * new collection.\r\n   *\r\n   * If an array is returned, the array will be flattened into the result\r\n   * collection.\r\n   *\r\n   * @param {function} callback\r\n   * @param {Type} type Force the new collection to be of a specific type\r\n   */\r\n  map(callback, type) {\r\n    const paths = [];\r\n    this.forEach(function(path) {\r\n      /*jshint eqnull:true*/\r\n      let result = callback.apply(path, arguments);\r\n      if (result == null) return;\r\n      if (!Array.isArray(result)) {\r\n        result = [result];\r\n      }\r\n      for (let i = 0; i < result.length; i++) {\r\n        if (paths.indexOf(result[i]) === -1) {\r\n          paths.push(result[i]);\r\n        }\r\n      }\r\n    });\r\n    return fromPaths(paths, this, type);\r\n  }\r\n\r\n  /**\r\n   * Returns the number of elements in this collection.\r\n   *\r\n   * @return {number}\r\n   */\r\n  size() {\r\n    return this.__paths.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of elements in this collection.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get length() {\r\n    return this.__paths.length;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of AST nodes in this collection.\r\n   *\r\n   * @return {Array}\r\n   */\r\n  nodes() {\r\n    return this.__paths.map(p => p.value);\r\n  }\r\n\r\n  paths() {\r\n    return this.__paths;\r\n  }\r\n\r\n  getAST() {\r\n    if (this._parent) {\r\n      return this._parent.getAST();\r\n    }\r\n    return this.__paths;\r\n  }\r\n\r\n  toSource(options) {\r\n    if (this._parent) {\r\n      return this._parent.toSource(options);\r\n    }\r\n    if (this.__paths.length === 1) {\r\n      return recast.print(this.__paths[0], options).code;\r\n    } else {\r\n      return this.__paths.map(p => recast.print(p, options).code);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new collection containing only the element at position index.\r\n   *\r\n   * In case of a negative index, the element is taken from the end:\r\n   *\r\n   *   .at(0)  - first element\r\n   *   .at(-1) - last element\r\n   *\r\n   * @param {number} index\r\n   * @return {Collection}\r\n   */\r\n  at(index) {\r\n    return fromPaths(\r\n      this.__paths.slice(\r\n        index,\r\n        index === -1 ? undefined : index + 1\r\n      ),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Proxies to NodePath#get of the first path.\r\n   *\r\n   * @param {string|number} ...fields\r\n   */\r\n  get() {\r\n    const path = this.__paths[0];\r\n    if (!path) {\r\n      throw Error(\r\n        'You cannot call \"get\" on a collection with no paths. ' +\r\n        'Instead, check the \"length\" property first to verify at least 1 path exists.'\r\n      );\r\n    }\r\n    return path.get.apply(path, arguments);\r\n  }\r\n\r\n  /**\r\n   * Returns the type(s) of the collection. This is only used for unit tests,\r\n   * I don't think other consumers would need it.\r\n   *\r\n   * @return {Array<string>}\r\n   */\r\n  getTypes() {\r\n    return this._types;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this collection has the type 'type'.\r\n   *\r\n   * @param {Type} type\r\n   * @return {boolean}\r\n   */\r\n  isOfType(type) {\r\n    return !!type && this._types.indexOf(type.toString()) > -1;\r\n  }\r\n}\r\n\r\n/**\r\n * Given a set of paths, this infers the common types of all paths.\r\n * @private\r\n * @param {Array} paths An array of paths.\r\n * @return {Type} type An AST type\r\n */\r\nfunction _inferTypes(paths) {\r\n  let _types = [];\r\n\r\n  if (paths.length > 0 && Node.check(paths[0].node)) {\r\n    const nodeType = types[paths[0].node.type];\r\n    const sameType = paths.length === 1 ||\r\n      paths.every(path => nodeType.check(path.node));\r\n\r\n    if (sameType) {\r\n      _types = [nodeType.toString()].concat(\r\n        astTypes.getSupertypeNames(nodeType.toString())\r\n      );\r\n    } else {\r\n      // try to find a common type\r\n      _types = intersection(\r\n        paths.map(path => astTypes.getSupertypeNames(path.node.type))\r\n      );\r\n    }\r\n  }\r\n\r\n  return _types;\r\n}\r\n\r\nfunction _toTypeArray(value) {\r\n  value = !Array.isArray(value) ? [value] : value;\r\n  value = value.map(v => v.toString());\r\n  if (value.length > 1) {\r\n    return union(\r\n      [value].concat(intersection(value.map(_getSupertypeNames)))\r\n    );\r\n  } else {\r\n    return value.concat(_getSupertypeNames(value[0]));\r\n  }\r\n}\r\n\r\nfunction _getSupertypeNames(type) {\r\n  try {\r\n    return astTypes.getSupertypeNames(type);\r\n  } catch(error) {\r\n    if (error.message === '') {\r\n      // Likely the case that the passed type wasn't found in the definition\r\n      // list. Maybe a typo. ast-types doesn't throw a useful error in that\r\n      // case :(\r\n      throw new Error(\r\n        '\"' + type + '\" is not a known AST node type. Maybe a typo?'\r\n      );\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new collection from an array of node paths.\r\n *\r\n * If type is passed, it will create a typed collection if such a collection\r\n * exists. The nodes or path values must be of the same type.\r\n *\r\n * Otherwise it will try to infer the type from the path list. If every\r\n * element has the same type, a typed collection is created (if it exists),\r\n * otherwise, a generic collection will be created.\r\n *\r\n * @ignore\r\n * @param {Array} paths An array of paths\r\n * @param {Collection} parent A parent collection\r\n * @param {Type} type An AST type\r\n * @return {Collection}\r\n */\r\nfunction fromPaths(paths, parent, type) {\r\n  assert.ok(\r\n    paths.every(n => n instanceof NodePath),\r\n    'Every element in the array should be a NodePath'\r\n  );\r\n\r\n  return new Collection(paths, parent, type);\r\n}\r\n\r\n/**\r\n * Creates a new collection from an array of nodes. This is a convenience\r\n * method which converts the nodes to node paths first and calls\r\n *\r\n *    Collections.fromPaths(paths, parent, type)\r\n *\r\n * @ignore\r\n * @param {Array} nodes An array of AST nodes\r\n * @param {Collection} parent A parent collection\r\n * @param {Type} type An AST type\r\n * @return {Collection}\r\n */\r\nfunction fromNodes(nodes, parent, type) {\r\n  assert.ok(\r\n    nodes.every(n => Node.check(n)),\r\n    'Every element in the array should be a Node'\r\n  );\r\n  return fromPaths(\r\n    nodes.map(n => new NodePath(n)),\r\n    parent,\r\n    type\r\n  );\r\n}\r\n\r\nconst CPt = Collection.prototype;\r\n\r\n/**\r\n * This function adds the provided methods to the prototype of the corresponding\r\n * typed collection. If no type is passed, the methods are added to\r\n * Collection.prototype and are available for all collections.\r\n *\r\n * @param {Object} methods Methods to add to the prototype\r\n * @param {Type=} type Optional type to add the methods to\r\n */\r\nfunction registerMethods(methods, type) {\r\n  for (const methodName in methods) {\r\n    if (!methods.hasOwnProperty(methodName)) {\r\n      return;\r\n    }\r\n    if (hasConflictingRegistration(methodName, type)) {\r\n      let msg = `There is a conflicting registration for method with name \"${methodName}\".\\nYou tried to register an additional method with `;\r\n\r\n      if (type) {\r\n        msg += `type \"${type.toString()}\".`\r\n      } else {\r\n        msg += 'universal type.'\r\n      }\r\n\r\n      msg += '\\nThere are existing registrations for that method with ';\r\n\r\n      const conflictingRegistrations = CPt[methodName].typedRegistrations;\r\n\r\n      if (conflictingRegistrations) {\r\n        msg += `type ${Object.keys(conflictingRegistrations).join(', ')}.`;\r\n      } else {\r\n        msg += 'universal type.';\r\n      }\r\n\r\n      throw Error(msg);\r\n    }\r\n    if (!type) {\r\n      CPt[methodName] = methods[methodName];\r\n    } else {\r\n      type = type.toString();\r\n      if (!CPt.hasOwnProperty(methodName)) {\r\n        installTypedMethod(methodName);\r\n      }\r\n      var registrations = CPt[methodName].typedRegistrations;\r\n      registrations[type] = methods[methodName];\r\n      astTypes.getSupertypeNames(type).forEach(function (name) {\r\n        registrations[name] = false;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nfunction installTypedMethod(methodName) {\r\n  if (CPt.hasOwnProperty(methodName)) {\r\n    throw new Error(`Internal Error: \"${methodName}\" method is already installed`);\r\n  }\r\n\r\n  const registrations = {};\r\n\r\n  function typedMethod() {\r\n    const types = Object.keys(registrations);\r\n\r\n    for (let i = 0; i < types.length; i++) {\r\n      const currentType = types[i];\r\n      if (registrations[currentType] && this.isOfType(currentType)) {\r\n        return registrations[currentType].apply(this, arguments);\r\n      }\r\n    }\r\n\r\n    throw Error(\r\n      `You have a collection of type [${this.getTypes()}]. ` +\r\n      `\"${methodName}\" is only defined for one of [${types.join('|')}].`\r\n    );\r\n  }\r\n\r\n  typedMethod.typedRegistrations = registrations;\r\n\r\n  CPt[methodName] = typedMethod;\r\n}\r\n\r\nfunction hasConflictingRegistration(methodName, type) {\r\n  if (!type) {\r\n    return CPt.hasOwnProperty(methodName);\r\n  }\r\n\r\n  if (!CPt.hasOwnProperty(methodName)) {\r\n    return false;\r\n  }\r\n\r\n  const registrations = CPt[methodName] && CPt[methodName].typedRegistrations;\r\n\r\n  if (!registrations) {\r\n    return true;\r\n  }\r\n\r\n  type = type.toString();\r\n\r\n  if (registrations.hasOwnProperty(type)) {\r\n    return true;\r\n  }\r\n\r\n  return astTypes.getSupertypeNames(type.toString()).some(function (name) {\r\n    return !!registrations[name];\r\n  });\r\n}\r\n\r\nvar _defaultType = [];\r\n\r\n/**\r\n * Sets the default collection type. In case a collection is created form an\r\n * empty set of paths and no type is specified, we return a collection of this\r\n * type.\r\n *\r\n * @ignore\r\n * @param {Type} type\r\n */\r\nfunction setDefaultCollectionType(type) {\r\n  _defaultType = _toTypeArray(type);\r\n}\r\n\r\nexports.fromPaths = fromPaths;\r\nexports.fromNodes = fromNodes;\r\nexports.registerMethods = registerMethods;\r\nexports.hasConflictingRegistration = hasConflictingRegistration;\r\nexports.setDefaultCollectionType = setDefaultCollectionType;\r\n"]},"metadata":{},"sourceType":"script"}